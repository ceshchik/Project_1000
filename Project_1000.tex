\documentclass{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{cmap}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tocloft}

\title{PROJECT 1000}
\author{Anton Layk, Cesh4, Mellstroy, ChickenBurger}
\date{January 2026}

% ---------- Listings ----------
\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{teal},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    breaklines=true,
    tabsize=2
}

\hypersetup{
    colorlinks,
    linkcolor={red!0!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}

\setcounter{tocdepth}{2}
\cftpagenumbersoff{subsection}


% ---------- Theorems ----------
\newtheorem{Problem}{Задача}[section]
\newtheorem{Theorem}{Теорема}[section]
\theoremstyle{definition}
\newtheorem{definitions}{Определение}[section]
\newtheorem{Proof}{Доказательство}[section]

\begin{document}

\maketitle
\tableofcontents
\newpage

%------------------------------------------------------------------------------------------------

% =============================
\section{Введение}
% =============================

\includegraphics[]{чикенбургер.png}

%------------------------------------------------------------------------------------------------

% =============================
\newpage
\section{Xor Basis}
% =============================

\subsection{Мотивация}

Как и с любым алгоритмом/техникой, для начала надо разобраться, какую задачу мы хотим научиться решать.

\begin{Problem}
Дан массив целых чисел $a$ размера $n$, $1 \le a_i <\ 2^{30}$. Надо отвечать на запросы вида: Дано число x, проверить, существует ли такой подмассив, что xor его элементов == x?
\end{Problem}

Для дальнейшей простоты введем некоторые определения:

\begin{definitions}
$\mathbb{Z}_2^d$ — множество векторов в $d$-мерном пространстве, где  
$x_1, x_2, \ldots, x_d \in \{0,1\}$.
\end{definitions}

\begin{definitions}
Векторное пространство — просто множество векторов.
\end{definitions}

\begin{definitions}
Множество векторов называется базисом векторного пространства, если каждый элемент этого пространства может быть \textbf{единственным} образом представлен линейной комбинацией базиса.
\end{definitions}

\begin{definitions}
Множество векторов называется независимым, если никакой из них не может быть представлен линейной комбинацией оставшихся.
\end{definitions}

% -----------------------------
\subsection{Алгоритм}
% -----------------------------

\textit{
Заметим, что числа представляются как вектора $\mathbb{Z}_2^d$.
Для этого надо взять их битовое представление.
Тогда xor — это сложение координат по модулю 2.
}

Будем поддерживать базис векторов, которые уже добавлены.
Пусть мы хотим добавить вектор $\vec{v}$.

\begin{enumerate}
\item Если $\vec{v}$ выражается через текущий базис — ничего не делаем.
\item Иначе надо добавить $\vec{v}$ в базис.
\end{enumerate}

Теперь остается только научиться проверять, можно ли составить $\vec{v}$ текущим базисом?

\begin{definitions}
Пусть $f(\vec{v})$ — максимальная позиция бита единицы в бинарном представлении вектора.
\end{definitions}

Будем хранить базис так, что все значения $f$ различны.

\begin{enumerate}
\item Если $f(\vec{v}) > f(\vec{b_1})$, то $\vec{v}$ нельзя выразить.
\item Если $f(\vec{v}) = f(\vec{b_1})$, заменяем  
$\vec{v} := \vec{v} - \vec{b_1}$ и продолжаем.
\end{enumerate}

\textbf{Итоговая асимптотика:}  
\[
O(n \cdot d) = O(n \log A)
\]

% -----------------------------
\subsection{Реализация}
% -----------------------------

\begin{lstlisting}[language=C++]
void insertVector(int mask) { 
    for (int i = LOG_A - 1; i >= 0; i--) {
        if ((mask & (1 << i)) == 0) continue;

        if (!basis[i]) {
            basis[i] = mask;
            return;
        }

        mask ^= basis[i];
    }
}
\end{lstlisting}

% -----------------------------
\subsection{Заключение}
% -----------------------------

\textbf{Ссылки для практики:}
\begin{enumerate}
\item \href{https://codeforces.com/contest/895/problem/C}{Codeforces div2 C}
\item \href{https://codeforces.com/contest/959/problem/F}{Codeforces div2 F}
\item \href{https://codeforces.com/contest/1101/problem/G}{Educational Codeforces G}
\end{enumerate}


%------------------------------------------------------------------------------------------------


% =============================
\newpage
\section{Persistent Centroid Decomposition}
% =============================

\subsection {Мотивация}
\textit{Эта статья является дополнением к базовой версии Centroid Decomposition.}
Поэтому, если вы не знаете базовую версию, рекомендую для начала озна-
комиться с ней.
\newline\newline
Для начала, давайте поставим задачу, которую мы хотим научиться решать.

\begin{Problem} 
Дано дерево из $n$ вершин, перестановка целых чисел $a_1, a_2, ... a_n$ длины $n$ $(1 \leq n \leq 10^5)$ и $q$ $(1 \leq q \leq 10^5)$ запросов вида:
\begin{itemize}
    \item l r v - посчитать \( \sum_{i=l}^{r} dist(a_i, v) \)
\end{itemize}
На запросы необходимо отвечать в \textbf{online}
\end{Problem}

\subsection{Идея решения}
Каждый запрос вида  $(l,\ r,\  v)$ можно разбить на два запроса:
$(1,\  r,\  v)$\:  -\: $(1,\  l-1,\  v)$. Поэтому для решения задачи достаточно научиться отвечать на запрос \textit{на префиксе}. Чтобы отвечать на такой запрос, можно рассматривать его как сумму расстояний до всех активированных вершин, если активированы все вершины на префиксе.
\newline
\newline
Мы уже можем решать эту задачу в \textbf{offline}, используя \textbf{\textit{Центроидную декомпозицию}}. Для решения задачи в \textbf{online}, центроидное дерево необходимо сделать \textbf{персистентным}.

\subsection{Алгоритм}
У каждой вершины центроидного дерева \textbf{не более \boldmath{\(log\ n\)} предков}, следовательно, при активации какой то вершины, можно просто \textit{подниматься по ее родителям и копировать их}, после чего уже обновить значения в них.
\newline
\newline
Проблема здесь заключается в том, что наше дерево не бинарное (у вершины может быть больше 2 детей). Из-за этого мы не сможем быстро копировать вершины. Давайте исправим это, \textbf{добавив дополнительные \textit{фиктивные} вершины в дерево}.

\subsection{Бинаризация дерева}
\begin{definitions}
Будем считать вершину \textit{бинарной}, если у нее не более 3 соседей.
\end{definitions}
\begin{definitions}
Будем считать дерево \textit{бинарным}, если все его вершины \textit{бинарные}
\end{definitions}

Рассмотрим вершину $v$ исходного дерева, у которой более 3 соседей. Пусть $b_1,b_2,..,b_k$ - список детей этой вершины. Для того, чтобы сделать $v$ бинарной, необходимо добавить новую вершину $u$ в дерево, добавить ребра $v-u$,\ $u-b_2$,\ $u-b_3$,\ ..,\ $u-b_k$\  и удалить ребра 
$v-b_2$,\ $v-b_3$,\ ..\ $v-b_k$. Проделаем эту операцию рекурсивно для всех $v$. Можно показать, что суммарно в дерево добавится не более $n$ новых вершин.
\newline
\newline
На получившемся бинарном дереве \textbf{\textit{запустим центроидную декомпозицию}}. Теперь, когда у каждой вершины не более 3 детей, \textit{их можно копировать за $O(1)$}.

\subsection{Заключение}
Проблема с бинаризацией дерева решена, следовательно, теперь мы \textit{можем за $O(log\  n)$ скопировать предков активируемой вершины и обновить в них значения}. После чего отвечать на запросы, обращаясь к нужным версиям \textbf{центроидного} дерева.
\newline
\newline
\textbf{Задачи для практики:}

\begin{enumerate}
\item \href{https://codeforces.com/contest/757/problem/G}{Div (1 + 2) G}
\end{enumerate}

%------------------------------------------------------------------------------------------------

% =============================
\newpage
\section{1D1D Optimization}
% =============================
\subsection{Мотивация}

\begin{definitions}
$w(j, i)$ - функция, удовлетворяющая условию четырехугольника: $w(a, c) + w(b, d) \leq w(a, d) + w(b, c)$, где $a \leq b \leq c \leq d$.
\end{definitions}

\noindent
Хотим научиться считать динамику вида: $dp_i=\min\limits_{j \leq i} \ dp_j + w(j, i)$ за асимптотику быстрее, чем $O(n^2)$.
Будем считать, что $dp_0 = 0$.
\newline
Конкретную задачу разберем позже. 

\subsection{Идея решения}
\begin{definitions}
$k(j, i) = \arg \min\limits_{x \leq j} dp_x + w(x, i)$. $(j < i)$ 
\newline Другими словами, $k(j, i)$ - точка оптимума, если мы прорелексировали $dp_i$ через $j$ первых значений. 
\end{definitions}
\noindent
Заметим, что если мы насчитали, $k(i - 1, i)$, то мы можем легко узнать значение $dp_i = dp_{k(i - 1, i)} + w_{k(i - 1, i)}$
% \newline
Также заметим, что если мы знаем $k(j, i)$, то можно насчитать $k(j + 1, i)$:
\begin{align*}
k(j + 1, i) = 
\begin{cases}
$j + 1$, & \text{если $j + 1$ - точка разреза} \\
$k(j, i)$, & \text{иначе}
\end{cases}
\end{align*}

\begin{center}
\textbf{То есть, чтобы обновить значение, надо проверить, что: }
\boldmath{$dp_{j + 1} + w(j + 1, i) < dp_{k(j, i)} + w(k(j, i), i)$}    
\end{center}

\begin{Theorem}
$k_j(i) = k(j, i)$ - неубывающая функция для $i = j, j+1,..n$.
\end{Theorem}

\noindent 
\begin{Proof}
    Пойдем от обратного. Пусть есть пары индексов $(j_1, i_1)$ и $(j_2, i_2)$ такие, что $j_1 = k_j(i_1)$ и $j_2 = k_j(i_2)$, причем $j_2 \leq j_1 \leq j <i_1 <i_2$. Тогда выполняются неравентсва

\begin{enumerate}
    \item $dp_{j_1} + w(j_1, i_1) < dp_{j_2} + w(j_2, i_1)$ 
    \item $dp_{j_2} + w(j_2, i_2) < dp_{j_1} + w(j_1, i_2)$ 
    \item $w(j_2, i_1) + w(j_1, i_2) \leq w(j_2, i_2) + w(j_1, i_1)$
\end{enumerate}

\noindent
Заметим, что $dp_{j_2} + w(j_2, i_2) \overset{(3)}{\geq} dp_{j_2} + w(j_2, i_1) + w(j_1, i_2) - w(j_1, i_1) \overset{(1)}{>} dp_{j_1} + w(j_1, i_1) + w(j_1, i_2) - w(j_1, i_1) = dp_{j_1} + w(j_1, i_2)$. \textbf{Получили противоречие с неравенством (2)}. 
\end{Proof}

\newpage
\subsection{Алгоритм}
\textbf{Теперь перейдем к реализации.} Для текущего j будем поддерживать значения $k_j(i)$ в виде дека отрезков разных значений (надо хранить начало отрезка и значение $k_j$ на нем). \textbf{Тогда чтобы посчитать значение \boldmath{$dp_{j+1}$} надо взять \boldmath{$k(j, j+1)$} из первого отрезка дека}. Далее надо обновиться на значения $k_{j + 1}(i)$.\textbf{ Удалим первый элемент и обновим дек соответствующе}. \textbf{Теперь надо найти суффикс на котором \boldmath{$k_{j + 1}(i) = j + 1$}. Это можно сделать бинпоиском.} 
Для некоторых задач мы можем найти начало отрезка без бинпоиска. Надо уметь считать функцию $D(j, i)$.
\begin{definitions}
$D(j, i)$ - минимальное значение x такое, что $dp_j + w(j, x) \geq dp_i + w(i, x)$    
\end{definitions}

\noindent
\textbf{Каждое значение отрезка добавляется и удаляется максимум один раз, значит асимптотика \boldmath{$O(n)$}, если мы можем считать \boldmath{$D(j, i)$} и \boldmath{$O(n \log n)$} иначе.}

\subsection{Пример}
Рассмотрим следующую \href{https://codeforces.com/contest/319/problem/C}{задачу}. Она сводится к подсчету динамики вида 
$dp_i = \min\limits_{j < i} {dp_j + a_i * b_j}$. Где массив $a$ отсортирован по возрастанию, а $b$ по убыванию.
Пусть $w(j, i) = b_j * a_i$. Тогда для функции выполняется неравенство четырехугольника и мы можем решить задачу 1D1D оптимизацией.
\href{https://github.com/ceshchik/Project_1000/blob/main/Implementations/1D1D.cpp}{Реализация} за $O(n \log n)$. Так же отмечу, что эту задачу можно решить за $O(n)$, однако это остается упражнением читателю.

% =============================
\newpage

\section{Queue Undo (Euphoria Trick)}
% =============================
\subsection{Мотивация}
Мы знаем такую структуру данных как СНМ с откатами. Она умеет добавлять ребра в конец и откатывать последние добавления. В каком то смысле это работает по принципу stack'а (добавить в конец и удалить из конца). Однако, что если нам надо откатывать первые добавления (как в queue)? Алгоритм, описанный далее позволит сделать это. Так же сразу определимся с задачей, которую хотим решить.
\begin{Problem}
Дан список из $m$ ребер. Посчитайте количество подотрезков $[l, r] \ (1 \leq l \leq r \leq m)$ таких, что граф на $n$ вершинах, содержащий только ребра из этого подотрезка, является связаным.  
\end{Problem}

\subsection{Идея решения}
Давайте подумаем, как это вообще можно делать. Будем хранить снм с откатами и порядок, в котором в нем объединялись компоненты. Пусть теперь нам пришел запрос объединения двух компонент, назовем тип этого добавления $A$. До первой операции $pop$ (откат начала) все хорошо, будем просто добавлять ребра в снм и сохранять порядок. Теперь рассмотрим, что делать при первом откате. Давайте воспользуемся классической идеей: \textbf{откатим все наши запросы и добавим их в обратном порядке, но теперь поменяем их тип на \boldmath{$B$}}. После этого мы можем просто откатить последнее изменение $B$. Но теперь, при добавлении нового запроса, у нас будет тип $A$ в конце, в то время, как откатить надо последний $B$. Назовем это проблемой stack'a. 
\subsection{Решение проблемы stack'a}
Итак, теперь у нас есть порядок в котором добавлены элементы в наш СНМ. Вновь рассмотрим запрос $pop$, однако теперь в массиве порядка добавлений могут быть как и $A$, так и $B$. \textbf{Найдем первый суффикс, в котором количество $B$ будет больше, чем $A$, либо возьмем всю строку, если такого суффикса нет. Откатим весь этот суффикс и добавим эти ребра в другом, более выгодном для нас порядке.} Какой же порядок будет для нас лучше всех? Очевидно, что сначала должны идти все $A$ из этого суффикса, а затем $B$ (так как теперь мы вновь можем легко откатывать). В случае, когда остались одни $A$, просто провернем трюк с разворотом всего массива из начала (и изменения типов соответственно). \textbf{Утверждается, что асимптотика данного решения амартизированно \boldmath{$O(n \log n)$}. }
\begin{Proof}
Для оценки асимптотики на самом деле нам лишь надо оценить $\sum_{i = 1}^{2n} o_i$, где $o_i$ - длинна суффикса, который мы переупорядочивали на шаге i, если это был шаг переупорядочивания и $0$ иначе. Заметим, что если $o_i \geq k$, $o_j \geq k$ и $j \geq i$, то $j - i \geq k$ $(1)$.   
Тогда: $\sum_{i = 1}^{2n} o_i = \sum_{i = 1}^{2n}\sum_{j = 1}^{o_i} 1 = \sum_{j = 0}^{\infty}\sum_{i = 1}^{2n}[o_i \geq j] \overset{(1)}{\leq} \sum_{i 
= 1}^{2n} \frac{2n}{i} = O(n \log n)$ 
\end{Proof}
\subsection{Решение задачи и заключение}
Теперь, когда мы научились делать откаты по принципу очереди, можно вернуться к задаче из начала. Давайте для каждого $i$ насчитаем $rgt_i$ - минимальную правую границу такую, что граф на $[i, rgt_i]$ - связанный. Очевидно, что этот массив будет возрастающий. Значит воспользуемся методом двух указателей: пока граф несвязанный, двигаем правую границу и добавляем соответствующее ребро, иначе левую и делаем откат. Теперь ответ на задачу это просто $\sum_{i = 1}^{n} n - rgt_i$. 
\newline 
Реализацию можно найти \href{https://github.com/ceshchik/Project_1000/blob/main/Implementations/QueueUndo.cpp}{тут}.
% =============================
\newpage
\section{Heavy-Light Decomposition \boldmath{$O(log \ n)$}}
% =============================
\subsection{Мотивация}
\textit{Эта статья является дополнением к базовой версии Heavy-Light Deomposition.} Поэтому, если вы не знаете базовую версию, рекомендую для начала ознакомиться с ней.
\newline\newline
Давайте поставим задачу, которую хотим научиться решать.
\begin{Problem}
    Дано дерево из $n$ вершин и массив целых чисел $a_1,\ a_2,\ ..,\ a_n$ $(1 \leq a_i \leq 10^9)$, где $a_v$ - число, записанное на вершине $v$. Поступают запросы двух типов:
    \begin{enumerate}
        \item $v$ $u$ - Найти максимальное число на кратчайшем пути от $v$ до $u$.
        \item $v$ $x$ - Присвоить $a_v$ значение $x$.
    \end{enumerate}
    Хочется научиться отвечать на запросы за \boldmath{$O(\log\ n)$}.
\end{Problem}

\subsection{Алгоритм}
Проблема базовой версии заключается в том, что тяжелые пути мы обрабатываем за \boldmath{$O(\log\ n)$}. Здесь $\log\ n$ появляется из-за обращения к структуре (например дереву отрезков). В этом случае дерево отрезков никак не пользуется размерами поддеревьев вершин. \textbf\textit{Тогда давайте модифицуруем его}.
\newline
\newline
Далее будет идти речь о каком-то тяжелом пути размера $k$. Обозначим за $s_1,\ s_2,\ ..,\ s_k$ размеры поддеревьев вершин без учета тяжелых сыновей. То есть $s_v$ - размер поддерева вершины $v$ минус размер поддерева ее \textit{тяжелого} сына. Пусть $S=\sum_{i=1}^k{s_i}$, то есть сумма всех $s_i$.  Обычно, в дереве отрезков, мы делим длину текущего отрезка пополам. Теперь, давайте делить отрезок пополам относительно $S$. Для отрезка $1,\ 2,\ ..,\ k$ его серединой будет такое минимальное $j$, что $\sum_{i = 1}^{j}s_i \geq \frac{S}{2}$. Иными словами, мы хотим, чтобы сумма $s_i$ в левой части была близка к $\frac{S}{2}$ (тогдя для правой части будет выполнятся то же самое). Тогда высота нашего ДО будет $\log\ S\leq \log\ n$ (так как $S\leq n$).
\newline
\newline
Заметим, что запрос на \textit{вертикальном пути} (то есть от вершины $v$ до вершины $u$ из поддерева $v$) разбивается на \textit{запросы к одному отрезку и префиксам тяжелых путей}. Этот один запрос на отрезке тяжелого пути мы можем обработать отдельно за $O(\log\ S)$. Теперь в случае с префиксами, давайте просто делать спуск по нашему ДО. Тогда \textbf{суммарно всех операций спуска будет не более $O(\log S)$}. 
\newline
\newline
\begin{Proof}
Почему же так? Давайте рассмотрим переход с одного тяжелого пути на другой. Пусть $S_1$ и $S_2$ - суммы $s_i$ на первом и втором тяжелых путях соответственно. Тогда при спуске по ДО на первом пути, $S_1$ \textit{будет уменьшаться в 2 раза}, и когда мы спустимся до листа $i$, значение $s_i$ сохранится для следующего тяжелого пути. Иными словами: $s_i\geq S_2$. Поэтому суммарно спуск сделает $O(\log\ S)$ операций.
\end{Proof}
\subsection{Заключение}
Теперь мы научились отвечать на запрос суммарно за $O(\log\ n)$. К сожалению, в реализации придется строить дерево отрезков на каждом тяжелом пути отдельно, из-за чего на практике это работает не сильно быстрее базового $O(\log^2 n)$ \textit{(но все равно быстрее)}.
\subsection{Реализация}
С реализацией можете ознакомиться по \href{https://github.com/ceshchik/Project_1000/blob/main/Implementations/Heavy-Light%20Decomposition.cpp}{ссылке}.

% =============================
\newpage
\section{Xor Segment Tree}
% =============================
\subsection{Мотивация}
Давайте поставим задачу, похожую на ту, что мы уже умеем решать деревом отрезков.

\begin{Problem}
    Дан массив $a_0,\ a_1,\ ..,\ a_{2^n - 1}$ размера $2^n$ $(0\leq n\leq 17)$. Поступают $q$ запрсы двух типов:
    \begin{enumerate}
        \item $l\ r\ k\ x$ - Заменить элементы $a_{l\oplus k},\ a_{(l+1)\oplus k,\ ..,\ a_{r\oplus k}}$ на число x.
        \item $l\ r\ k$ - Вывести сумму элементов $a_{l\oplus k},\ a_{(l+1)\oplus k,\ ..,\ a_{r\oplus k}}$.
    \end{enumerate}
    $\oplus$ - операция побитового исключающего \textit{ИЛИ (XOR)}
\end{Problem}

\subsection{Алгоритм}
\textit{Далее будет очень важно, что размер массива является \textbf{степенью двойки}, если это не так, дополните его фиктивными элементами}.
\newline\newline
Пусть нам дан запрос с числом $k$. Давайте посмотрим на битовую запись этого числа. Теперь, можно заметить, что бит $i$ в этом представлении будет соответствовать уровню $i + 1$ дерева отрезков (если счить снизу). Это значит, что если мы сейчас находимся в какой то вершине $v$ на уровне $i + 1$ дерева отрезков, то ее левый сын отвечает за отрезок, где бит $i$ выключен, а правый за тот, где включен. Получается, что если на позиции $i$ битовой записи числа $k$ стоит $1$, то на уровне $i + 1$ ДО необходимо поменять для каждой вершины левого и правого сыновей местами.

\subsection{Заключение}
Получается, что единственное изменение в базовом ДО будет то, что на уровне $i + 1$ мы смотрим на бит $i$ в битовой записи числа $k$ из запроса, если он равен $1$, то надо поменять сыновей местами, и затем запускаться как обычно, а если бит $0$, то ничего менять не надо, и просто запускаемся как в обычном ДО. C реализацией можете ознакомиться по \href{https://github.com/ceshchik/Project_1000/blob/main/Implementations/Xor%20Segment%20Tree.cpp}{ссылке}.
% =============================
\newpage
\section{Linear Memory Binary Lifting}
% =============================
\newpage 
\section{}

\end{document}
